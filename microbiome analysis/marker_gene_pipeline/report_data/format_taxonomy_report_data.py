#!/usr/bin/env python3

__author__ = "Arun Manoharan (arun@primediscoveries.com)"

import collections
import csv
import datetime
import glob
import os
import os.path
import sys

try:
    import click
    import pandas as pd
    import qiime2
except ImportError as e:
    sys.exit(
        "Couldn't import required dependencies. Please ensure that a qiime2 "
        "conda environment is activated prior to running this script (use "
        "install/create_conda_envs.sh to create one).\n\n"
        "Original error message: %s" % e)

DB_INFO = {
    'gg_13_8': {
        'prefixes': ['k__', 'p__', 'c__', 'o__', 'f__', 'g__', 's__'],
        'display_prefixes': {
            'k__': 'K',
            'p__': 'P',
            'c__': 'C',
            'o__': 'O',
            'f__': 'F',
            'g__': 'G',
            's__': 'S'
        }
    }
}


@click.command()
@click.option('--taxonomy_dir', required=True,
              type=click.Path(exists=True, file_okay=False, dir_okay=True,
                              readable=True),
              help="Directory containing taxonomy classification results "
                   "generated by classify_taxonomy.sh.")
@click.option('--sample_id', required=True,
              help="Sample ID for which to format taxonomy report data. This "
                   "sample ID must exist in --taxonomy_dir. All other samples "
                   "in --taxonomy_dir will be treated as a baseline in "
                   "comparative analyses (e.g. 'comparison-most-abundant' "
                   "report data).")
@click.option('--output_dir', required=True,
              type=click.Path(exists=False, file_okay=False, dir_okay=True,
                              writable=True),
              help="Output directory in which to write the sample's taxonomy "
                   "report data.")
@click.option('--min_abundance', required=False, type=float,
              default=0.0001, show_default=True,
              help="Minimum relative abundance for a taxon to be included in "
                   "'composition' report data. If a taxon falls below this "
                   "threshold it is grouped in an 'Other' category. This "
                   "relative abundance threshold should be specified as a "
                   "proportion (e.g. 0.0001 is 0.01%).")
@click.option('--top_n_most_abundant', required=False,
              type=click.IntRange(min=1), default=20, show_default=True,
              help="How many taxa to include in 'comparison-most-abundant' "
                   "report data.")
@click.option('--hierarchy_level', required=False, type=str, default='genus',
              show_default=True,
              help="Most specific taxonomic level for which to generate "
                   "'hierarchical-composition' report data.")
@click.option('--database', required=False, type=click.Choice(['gg_13_8']),
              default='gg_13_8', show_default=True,
              help="Reference database used to generate taxonomy "
                   "classification results in --taxonomy_dir. Only gg_13_8 is "
                   "supported at this time.")
def format_taxonomy_report_data(taxonomy_dir, sample_id, output_dir,
                                min_abundance, top_n_most_abundant,
                                hierarchy_level, database):
    """Format taxonomy report data for a client's sample.

    Generates formatted taxonomy report data for a client's sample. This report
    data is intended to be rendered in report visualizations.

    Generates the following report results:

    "composition": TSV file for each taxonomic level containing relative
    abundances of taxa present in the client's sample. Any taxa that could not
    be classified to a given level (e.g. '__') or are unnamed at a given level
    in the reference database (e.g. 'g__') are grouped into an "Other"
    category. Any taxa with relative abundances below --min_abundance threshold
    are also grouped into "Other".

    "comparison-most-abundant": TSV file for each taxonomic level containing
    the "Top N" most abundant taxa present in the client's sample (where N can
    be set with --top_n_most_abundant). Any taxa that could not be classified
    to a given level (e.g. '__') or are unnamed at a given level in the
    reference database (e.g. 'g__') are ignored, regardless of their abundance
    ranking. Each "Top N" taxon includes its median relative abundance found in
    the baseline (the baseline is defined by all other samples in
    --taxonomy_dir, excluding the client's sample).

    "hierarchical-composition": a single TSV file containing relative
    abundances of taxa present in the client's sample. Each taxon is reported
    down to its lowest recognized level (e.g. some taxa will be reported to
    genus level, others will only be reported to family, etc). The most
    specific level to generate results for can be set with --hierarchy_level.

    In each of the above results, taxa are labelled with reference database
    taxonomy IDs (e.g. for linking to microbe summaries), as well as full and
    short human-readable display names. Square brackets ('[' and ']') in taxa
    labels are not significant; square brackets are removed from the label and
    any identical taxa labels are grouped and summed (e.g. 'g__Ruminococcus'
    and 'g__[Ruminococcus]' would be grouped together as 'g__Ruminococcus').

    Example usage:

    \b
    python format_taxonomy_report_data.py
        --taxonomy_dir merged_samples/taxonomy/gg-13-8-99-nb-classifier
        --sample_id SAMPLEID
        --output_dir taxonomy_report_data

    """
    if os.path.exists(output_dir):
        raise click.ClickException(
            "%r directory already exists. Please either remove the directory "
            "and rerun this script or specify a different --output_dir." %
            output_dir)

    os.makedirs(output_dir)

    log = os.path.join(output_dir, 'format_taxonomy_report_data.log')

    pipeline_started = datetime.datetime.now().strftime('%Y-%m-%d:%H:%M:%S')
    log_message("Pipeline execution started.", log)

    log_message("Writing file of input parameters started.", log)

    params_log = os.path.join(output_dir,
                              "format_taxonomy_report_data_params.log")
    with open(params_log, 'w') as f:
        f.write("TAXONOMY_DIR: %s\n" % taxonomy_dir)
        f.write("SAMPLE_ID: %s\n" % sample_id)
        f.write("OUTPUT_DIR: %s\n" % output_dir)
        f.write("MIN_ABUNDANCE: %s\n" % min_abundance)
        f.write("TOP_N_MOST_ABUNDANT: %s\n" % top_n_most_abundant)
        f.write("HIERARCHY_LEVEL: %s\n" % hierarchy_level)
        f.write("DATABASE: %s\n" % database)

    log_message("Writing file of input parameters completed.", log)

    log_message("Creating output directories started.", log)

    composition_output_dir = os.path.join(output_dir, 'composition')
    os.makedirs(composition_output_dir)

    most_abundant_output_dir = os.path.join(output_dir,
                                            'comparison-most-abundant')
    os.makedirs(most_abundant_output_dir)

    hierarchy_output_dir = os.path.join(output_dir, 'hierarchical-composition')
    os.makedirs(hierarchy_output_dir)

    log_message("Creating output directories completed.", log)

    found_hierarchy_level = False
    for level_dir in sorted(glob.glob(os.path.join(taxonomy_dir, 'level_*'))):
        log_message(
            "Processing taxonomy level directory %r started." % level_dir, log)

        level_name = os.path.basename(level_dir).split('_', maxsplit=2)[2]
        table_path = os.path.join(level_dir, '%s_level_table.qza' % level_name)

        log_message("Loading taxonomy table %r started." % table_path, log)

        table_artifact = qiime2.Artifact.load(table_path)
        table_df = table_artifact.view(pd.DataFrame)

        if sample_id not in table_df.index:
            raise click.ClickException(
                "Sample ID %r is not present in taxonomy table %r." %
                (sample_id, table_path))

        # Remove any square brackets from taxa labels, and group any identical
        # column names by summing their abundances.
        #
        # Note: the choice to treat square brackets as insignificant is
        # specific to Greengenes taxonomy labels. Square brackets indicate the
        # Greengenes taxonomy label differs from the NCBI taxonomy. We choose
        # to ignore this distinction for consumer display and group NCBI and
        # Greengenes taxonomy labels together for simplicity. If a
        # non-Greengenes database is supported in the future, this behavior
        # should be re-evaluated since square brackets may have different
        # meaning for that reference database.
        table_df.columns = [col.replace('[', '').replace(']', '')
                            for col in table_df.columns]
        # `sort=False` speeds this up slightly, and we don't need the results
        # to be in any particular order.
        table_df = table_df.groupby(axis=1, level=0, sort=False).sum()

        sample_series = table_df.loc[sample_id]
        baseline_df = table_df.drop(index=[sample_id])

        if len(baseline_df.index) == 0:
            raise click.ClickException(
                "There must be at least one baseline sample to compare to "
                "sample %r." % (sample_id))

        log_message("Loading taxonomy table %r completed." % table_path, log)

        log_message(
            "Formatting composition data for %s level started." % level_name,
            log)

        format_composition_data(composition_output_dir, level_name,
                                sample_series, min_abundance, database)

        log_message(
            "Formatting composition data for %s level completed." % level_name,
            log)

        log_message("Formatting comparison-most-abundant data for %s level "
                    "started." % level_name, log)

        format_most_abundant_data(most_abundant_output_dir, level_name,
                                  sample_series, baseline_df,
                                  top_n_most_abundant, database)

        log_message("Formatting comparison-most-abundant data for %s level "
                    "completed." % level_name, log)

        if level_name == hierarchy_level:
            log_message("Formatting hierarchical-composition data for %s "
                        "level started." % level_name, log)

            found_hierarchy_level = True
            format_hierarchy_data(hierarchy_output_dir, sample_series,
                                  database)

            log_message("Formatting hierarchical-composition data for %s "
                        "level completed." % level_name, log)

        log_message(
            "Processing taxonomy level directory %r completed." % level_dir,
            log)

    if not found_hierarchy_level:
        raise click.ClickException(
            "Failed to locate taxonomy results for specified hierarchy level "
            "%r. Please ensure taxonomy results exist for this level in "
            "--taxonomy_dir, or specify a different level with "
            "--hierarchy_level." % hierarchy_level)

    pipeline_completed = datetime.datetime.now().strftime('%Y-%m-%d:%H:%M:%S')
    with open(os.path.join(output_dir, 'pipeline_completed.log'), 'w') as f:
        f.write('%s Pipeline execution started.\n' % pipeline_started)
        f.write('%s Pipeline execution completed.\n' % pipeline_completed)
    log_message("Pipeline execution completed.", log)


def log_message(msg, filepath):
    """Write message with timestamp to log file and also display on stdout.

    Will create log file if it does not already exist.

    """
    if not os.path.exists(filepath):
        with open(filepath, 'w') as f:
            f.write("format_taxonomy_report_data.py log file\n\n")

    msg = '%s %s' % (datetime.datetime.now().strftime('%Y-%m-%d:%H:%M:%S'),
                     msg)
    click.echo(msg)
    with open(filepath, 'a') as f:
        f.write('%s\n' % msg)


def format_composition_data(output_dir, level_name, sample_series,
                            min_abundance, database):
    prefixes = DB_INFO[database]['prefixes']

    data = []
    other_abundance = 0.0
    for label, abundance in sample_series.iteritems():
        names = parse_taxonomy_label(label, database)

        is_other_group = (
            abundance < min_abundance or
            names[-1] == '__' or
            names[-1] == prefixes[len(names) - 1]
        )
        if is_other_group:
            other_abundance += abundance
            continue

        taxonomy_id, full_name, short_name = format_taxonomy_label(names,
                                                                   database)
        data.append([taxonomy_id, full_name, short_name,
                     '{0:.15g}'.format(abundance)])

    if other_abundance > 0.0:
        data.append(['N/A', 'N/A', 'Other',
                     '{0:.15g}'.format(other_abundance)])

    header = ['taxonomy_id', 'full_name', 'short_name', 'value']
    output_path = os.path.join(output_dir, '%s.tsv' % level_name)
    write_tsv(output_path, header, data)


def format_most_abundant_data(output_dir, level_name, sample_series,
                              baseline_df, top_n_most_abundant, database):
    prefixes = DB_INFO[database]['prefixes']
    sample_series = sample_series.sort_values(ascending=False)

    data = []
    for label, abundance in sample_series.iteritems():
        if len(data) == top_n_most_abundant:
            break

        names = parse_taxonomy_label(label, database)

        is_other_group = (
            abundance == 0.0 or
            names[-1] == '__' or
            names[-1] == prefixes[len(names) - 1]
        )
        if is_other_group:
            continue

        taxonomy_id, full_name, short_name = format_taxonomy_label(names,
                                                                   database)
        baseline_abundance = baseline_df.loc[:, label].median()

        data.append([taxonomy_id, full_name, short_name,
                     '{0:.15g}'.format(abundance),
                     '{0:.15g}'.format(baseline_abundance),
                     '{0:.1f}'.format(abundance / baseline_abundance) if baseline_abundance else 'N/A'])

    header = ['taxonomy_id', 'full_name', 'short_name', 'value', 'reference', 'fold_change']
    output_path = os.path.join(output_dir, '%s.tsv' % level_name)
    write_tsv(output_path, header, data)


def format_hierarchy_data(output_dir, sample_series, database):
    prefixes = DB_INFO[database]['prefixes']

    data = collections.defaultdict(float)
    for label, abundance in sample_series.iteritems():
        if abundance == 0.0:
            continue

        names = parse_taxonomy_label(label, database)

        lowest_level = None
        for level_num, name in enumerate(names):
            prefix = prefixes[level_num]
            if name == '__' or name == prefix:
                break
            else:
                lowest_level = level_num

        if lowest_level is None:
            raise click.ClickException(
                "Taxon label %r is unclassified at the highest taxonomic "
                "level." % label)

        key = tuple(names[:lowest_level+1])
        data[key] += abundance

    data_rows = []
    for names, abundance in data.items():
        taxonomy_id, full_name, short_name = format_taxonomy_label(names,
                                                                   database)
        data_rows.append([taxonomy_id, full_name, short_name,
                          '{0:.15g}'.format(abundance)])

    header = ['taxonomy_id', 'full_name', 'short_name', 'value']
    output_path = os.path.join(output_dir, 'data.tsv')
    write_tsv(output_path, header, data_rows)


def parse_taxonomy_label(label, database):
    prefixes = DB_INFO[database]['prefixes']

    names = [name.strip() for name in label.split(';')]

    if len(names) > len(prefixes):
        raise click.ClickException(
            "Taxon label %r has %d levels, which exceeds the %d recognized "
            "levels in the %r reference database. Please verify the results "
            "in --taxonomy_dir were generated with the %r reference database."
            % (label, len(names), len(prefixes), database, database))

    return names


def format_taxonomy_label(names, database):
    prefixes = DB_INFO[database]['prefixes']
    display_prefixes = DB_INFO[database]['display_prefixes']

    taxonomy_id = '%s:%s' % (database, ';'.join(names))

    # Handle the case where a sequence couldn't be classified even at the
    # kingdom level.
    #
    # Note: `names` can be a list or tuple, so we just check the length and
    # contents of the first element instead of comparing to a list or tuple
    # directly.
    if len(names) == 1 and names[0] == 'Unassigned':
        full_name = names[0]
        short_name = names[0]
    else:
        display_names = []
        for level_num, name in enumerate(names):
            prefix = prefixes[level_num]

            if not name.startswith(prefix):
                raise click.ClickException(
                    "Taxon name %r at level %d does not start with the "
                    "expected prefix %r. Please verify the results in "
                    "--taxonomy_dir were generated with the %r reference "
                    "database." % (name, level_num + 1, prefix, database))

            display_name = name[len(prefix):]
            display_names.append((display_prefixes[prefix], display_name))

        full_name = '; '.join('%s: %s' % (prefix, name)
                              for prefix, name in display_names)
        short_name = display_names[-1][1]

    return taxonomy_id, full_name, short_name


def write_tsv(output_path, header, data):
    with open(output_path, 'w', newline='', encoding='utf-8') as fh:
        tsv_writer = csv.writer(fh, dialect='excel-tab', strict=True)
        tsv_writer.writerow(header)
        tsv_writer.writerows(data)


if __name__ == '__main__':
    format_taxonomy_report_data()
